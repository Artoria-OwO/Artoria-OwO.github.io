<h1>Java Hashmap compared to C++ stl::map</h1>

<h2>Java Hashmap Implementation:</h2>

<p><code>
map.put()
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //(n-1)&amp;hash : get array index, control hash value less than n
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            //put same key and value 
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            //else : hash conflict
            //RBTree
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            //walkthrough linked node list
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //TREEIFY_THRESHOLD = 8
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></p>

<p><code>
//map.get()
final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
</code></p>

<p>Java use hash table to store node, which use hash(key) as index. When there is no hash conflict, the put() and get() method time complexity is O(1). </p>

<p>When there exists hash conflict, java use linked list to store nodes which has same hash result.While the list size is greater or equal to 7, java will transfer linked list to Red Black Tree,which has a steady complexity O(log(n)).</p>

<p>In a word,java use hash table and Red Black tree to ensure code performance, the best time cost is O(1) while the worst is O(log(n)).</p>

<h2>C++ Hashmap Implementation:</h2>

<p>C++ use RBTree as map, insert() and find() method time complexity is steady O(log(n)).</p>

<p><code></code>`</p>

<h1>define BLACK 1</h1>

<h1>define RED 0</h1>

<h1>include &lt;iostream&gt;</h1>

<p>using namespace std;</p>

<p>class rbtree
{
private:
    struct Node
    {
        int value;
        bool color;
        Node <em>leftTree, </em>rightTree, *parent;</p>

<pre><code>    Node() : value(0), color(RED), leftTree(NULL), rightTree(NULL), parent(NULL) {}

    Node *grandparent()
    {
        if (parent == NULL)
        {
            return NULL;
        }
        return parent-&gt;parent;
    }

    Node *uncle()
    {
        if (grandparent() == NULL)
        {
            return NULL;
        }
        if (parent == grandparent()-&gt;rightTree)
            return grandparent()-&gt;leftTree;
        else
            return grandparent()-&gt;rightTree;
    }

    Node *sibling()
    {
        if (parent-&gt;leftTree == this)
            return parent-&gt;rightTree;
        else
            return parent-&gt;leftTree;
    }
};

void rotate_right(Node *p)
{
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;rightTree;

    fa-&gt;leftTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;rightTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL)
    {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }
}

void rotate_left(Node *p)
{
    if (p-&gt;parent == NULL)
    {
        root = p;
        return;
    }
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;leftTree;

    fa-&gt;rightTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;leftTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL)
    {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }
}

void inorder(Node *p)
{
    if (p == NIL)
        return;

    if (p-&gt;leftTree)
        inorder(p-&gt;leftTree);

    cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;

    if (p-&gt;rightTree)
        inorder(p-&gt;rightTree);
}

string outputColor(bool color)
{
    return color ? &quot;BLACK&quot; : &quot;RED&quot;;
}

Node *getSmallestChild(Node *p)
{
    if (p-&gt;leftTree == NIL)
        return p;
    return getSmallestChild(p-&gt;leftTree);
}

bool delete_child(Node *p, int data)
{
    if (p-&gt;value &gt; data)
    {
        if (p-&gt;leftTree == NIL)
        {
            return false;
        }
        return delete_child(p-&gt;leftTree, data);
    }
    else if (p-&gt;value &lt; data)
    {
        if (p-&gt;rightTree == NIL)
        {
            return false;
        }
        return delete_child(p-&gt;rightTree, data);
    }
    else if (p-&gt;value == data)
    {
        if (p-&gt;rightTree == NIL)
        {
            delete_one_child(p);
            return true;
        }
        Node *smallest = getSmallestChild(p-&gt;rightTree);
        swap(p-&gt;value, smallest-&gt;value);
        delete_one_child(smallest);

        return true;
    }
    else
    {
        return false;
    }
}

void delete_one_child(Node *p)
{
    Node *child = p-&gt;leftTree == NIL ? p-&gt;rightTree : p-&gt;leftTree;
    if (p-&gt;parent == NULL &amp;&amp; p-&gt;leftTree == NIL &amp;&amp; p-&gt;rightTree == NIL)
    {
        p = NULL;
        root = p;
        return;
    }

    if (p-&gt;parent == NULL)
    {
        delete p;
        child-&gt;parent = NULL;
        root = child;
        root-&gt;color = BLACK;
        return;
    }

    if (p-&gt;parent-&gt;leftTree == p)
    {
        p-&gt;parent-&gt;leftTree = child;
    }
    else
    {
        p-&gt;parent-&gt;rightTree = child;
    }
    child-&gt;parent = p-&gt;parent;

    if (p-&gt;color == BLACK)
    {
        if (child-&gt;color == RED)
        {
            child-&gt;color = BLACK;
        }
        else
            delete_case(child);
    }

    delete p;
}

void delete_case(Node *p)
{
    if (p-&gt;parent == NULL)
    {
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;sibling()-&gt;color == RED)
    {
        p-&gt;parent-&gt;color = RED;
        p-&gt;sibling()-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree)
            //rotate_left(p-&gt;sibling());
            rotate_left(p-&gt;parent);
        else
            //rotate_right(p-&gt;sibling());
            rotate_right(p-&gt;parent);
    }
    if (p-&gt;parent-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK)
    {
        p-&gt;sibling()-&gt;color = RED;
        delete_case(p-&gt;parent);
    }
    else if (p-&gt;parent-&gt;color == RED &amp;&amp; p-&gt;sibling()-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK)
    {
        p-&gt;sibling()-&gt;color = RED;
        p-&gt;parent-&gt;color = BLACK;
    }
    else
    {
        if (p-&gt;sibling()-&gt;color == BLACK)
        {
            if (p == p-&gt;parent-&gt;leftTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == RED &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK)
            {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
                rotate_right(p-&gt;sibling()-&gt;leftTree);
            }
            else if (p == p-&gt;parent-&gt;rightTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == RED)
            {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
                rotate_left(p-&gt;sibling()-&gt;rightTree);
            }
        }
        p-&gt;sibling()-&gt;color = p-&gt;parent-&gt;color;
        p-&gt;parent-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree)
        {
            p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
            rotate_left(p-&gt;sibling());
        }
        else
        {
            p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
            rotate_right(p-&gt;sibling());
        }
    }
}

void insert(Node *p, int data)
{
    if (p-&gt;value &gt;= data)
    {
        if (p-&gt;leftTree != NIL)
            insert(p-&gt;leftTree, data);
        else
        {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;leftTree = tmp;
            insert_case(tmp);
        }
    }
    else
    {
        if (p-&gt;rightTree != NIL)
            insert(p-&gt;rightTree, data);
        else
        {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;rightTree = tmp;
            insert_case(tmp);
        }
    }
}

void insert_case(Node *p)
{
    if (p-&gt;parent == NULL)
    {
        root = p;
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;parent-&gt;color == RED)
    {
        if (p-&gt;uncle()-&gt;color == RED)
        {
            p-&gt;parent-&gt;color = p-&gt;uncle()-&gt;color = BLACK;
            p-&gt;grandparent()-&gt;color = RED;
            insert_case(p-&gt;grandparent());
        }
        else
        {
            if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent)
            {
                rotate_left(p);
                p-&gt;color = BLACK;
                p-&gt;parent-&gt;color = RED;
                rotate_right(p);
            }
            else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent)
            {
                rotate_right(p);
                p-&gt;color = BLACK;
                p-&gt;parent-&gt;color = RED;
                rotate_left(p);
            }
            else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent)
            {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_right(p-&gt;parent);
            }
            else if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent)
            {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_left(p-&gt;parent);
            }
        }
    }
}

void DeleteTree(Node *p)
{
    if (!p || p == NIL)
    {
        return;
    }
    DeleteTree(p-&gt;leftTree);
    DeleteTree(p-&gt;rightTree);
    delete p;
}

Node *find(Node *node, int value)
{
    while (node != NULL)
    {
        if (node-&gt;value == value)
        {
            return node;
        }
        else if (node-&gt;value &lt; value)
        {
            node = node-&gt;rightTree;
        }
        else
        {
            node = node-&gt;leftTree;
        }
    }
    return NULL;
}</code></pre>

<p>public:
    rbtree()
    {
        NIL = new Node();
        NIL-&gt;color = BLACK;
        root = NULL;
    }</p>

<pre><code>~rbtree()
{
    if (root)
        DeleteTree(root);
    delete NIL;
}

void inorder()
{
    if (root == NULL)
        return;
    inorder(root);
    cout &lt;&lt; endl;
}

void insert(int x)
{
    if (root == NULL)
    {
        root = new Node();
        root-&gt;color = BLACK;
        root-&gt;leftTree = root-&gt;rightTree = NIL;
        root-&gt;value = x;
    }
    else
    {
        insert(root, x);
    }
}

bool delete_value(int data)
{
    return delete_child(root, data);
}

Node *find(int value)
{
    return find(root, value);
}</code></pre>

<p>private:
    Node <em>root, </em>NIL;
};</p>

<p><code></code>`</p>
